import { __decorate, __param } from "tslib";
import { Directive, ElementRef, forwardRef, Input, Inject, NgModule, OnChanges, Optional, Provider, SimpleChanges, Injectable, RendererFactory2 } from '@angular/core';
import { NG_VALUE_ACCESSOR, COMPOSITION_BUFFER_MODE } from '@angular/forms';
import { ÉµgetDOM as getDOM, BrowserModule } from '@angular/platform-browser';
import { createTextMaskInputElement } from 'text-mask-core/dist/textMaskCore';
var TextMaskConfig = /** @class */ (function () {
    function TextMaskConfig() {
    }
    return TextMaskConfig;
}());
export { TextMaskConfig };
export var MASKEDINPUT_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(function () { return MaskedInputDirective; }),
    multi: true
};
/**
 * We must check whether the agent is Android because composition events
 * behave differently between iOS and Android.
 */
function _isAndroid() {
    var userAgent = getDOM() ? getDOM().getUserAgent() : '';
    return /android (\d+)/.test(userAgent.toLowerCase());
}
var MaskedInputDirective = /** @class */ (function () {
    function MaskedInputDirective(rendererFactory, _elementRef, _compositionMode) {
        this._elementRef = _elementRef;
        this._compositionMode = _compositionMode;
        this.textMaskConfig = {
            mask: [],
            guide: true,
            placeholderChar: '_',
            pipe: undefined,
            keepCharPositions: false,
        };
        this.onChange = function (_) { };
        this.onTouched = function () { };
        /** Whether the user is creating a composition string (IME events). */
        this._composing = false;
        this._renderer = rendererFactory.createRenderer(null, null);
        if (this._compositionMode == null) {
            this._compositionMode = !_isAndroid();
        }
    }
    MaskedInputDirective.prototype.ngOnChanges = function (changes) {
        this._setupMask(true);
        if (this.textMaskInputElement !== undefined) {
            this.textMaskInputElement.update(this.inputElement.value);
        }
    };
    MaskedInputDirective.prototype.writeValue = function (value) {
        this._setupMask();
        // set the initial value for cases where the mask is disabled
        var normalizedValue = value == null ? '' : value;
        this._renderer.setProperty(this.inputElement, 'value', normalizedValue);
        if (this.textMaskInputElement !== undefined) {
            this.textMaskInputElement.update(value);
        }
    };
    MaskedInputDirective.prototype.registerOnChange = function (fn) { this.onChange = fn; };
    MaskedInputDirective.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
    MaskedInputDirective.prototype.setDisabledState = function (isDisabled) {
        this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
    };
    MaskedInputDirective.prototype._handleInput = function (value) {
        if (!this._compositionMode || (this._compositionMode && !this._composing)) {
            this._setupMask();
            if (this.textMaskInputElement !== undefined) {
                this.textMaskInputElement.update(value);
                // get the updated value
                value = this.inputElement.value;
                this.onChange(value);
            }
        }
    };
    MaskedInputDirective.prototype._setupMask = function (create) {
        if (create === void 0) { create = false; }
        if (!this.inputElement) {
            if (this._elementRef.nativeElement.tagName.toUpperCase() === 'INPUT') {
                // `textMask` directive is used directly on an input element
                this.inputElement = this._elementRef.nativeElement;
            }
            else {
                // `textMask` directive is used on an abstracted input element, `md-input-container`, etc
                this.inputElement = this._elementRef.nativeElement.getElementsByTagName('INPUT')[0];
            }
        }
        if (this.inputElement && create) {
            this.textMaskInputElement = createTextMaskInputElement(Object.assign({ inputElement: this.inputElement }, this.textMaskConfig));
        }
    };
    MaskedInputDirective.prototype._compositionStart = function () { this._composing = true; };
    MaskedInputDirective.prototype._compositionEnd = function (value) {
        this._composing = false;
        this._compositionMode && this._handleInput(value);
    };
    MaskedInputDirective.ctorParameters = function () { return [
        { type: RendererFactory2 },
        { type: ElementRef },
        { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: [COMPOSITION_BUFFER_MODE,] }] }
    ]; };
    __decorate([
        Input('textMask')
    ], MaskedInputDirective.prototype, "textMaskConfig", void 0);
    MaskedInputDirective = __decorate([
        Injectable(),
        Directive({
            host: {
                '(input)': '_handleInput($event.target.value)',
                '(blur)': 'onTouched()',
                '(compositionstart)': '_compositionStart()',
                '(compositionend)': '_compositionEnd($event.target.value)'
            },
            selector: '[textMask]',
            exportAs: 'textMask',
            providers: [MASKEDINPUT_VALUE_ACCESSOR]
        }),
        __param(2, Optional()), __param(2, Inject(COMPOSITION_BUFFER_MODE))
    ], MaskedInputDirective);
    return MaskedInputDirective;
}());
export { MaskedInputDirective };
var TextMaskModule = /** @class */ (function () {
    function TextMaskModule() {
    }
    TextMaskModule = __decorate([
        NgModule({
            imports: [
                BrowserModule
            ],
            declarations: [MaskedInputDirective],
            exports: [MaskedInputDirective]
        })
    ], TextMaskModule);
    return TextMaskModule;
}());
export { TextMaskModule };
export { conformToMask } from 'text-mask-core/dist/textMaskCore';
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ndWxhcjJUZXh0TWFzay5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25nLWJyYXppbC8iLCJzb3VyY2VzIjpbImFuZ3VsYXIyVGV4dE1hc2sudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFDTCxTQUFTLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFDMUQsU0FBUyxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsYUFBYSxFQUFFLFVBQVUsRUFBRSxnQkFBZ0IsRUFDM0UsTUFBTSxlQUFlLENBQUE7QUFDdEIsT0FBTyxFQUFFLGlCQUFpQixFQUF3Qix1QkFBdUIsRUFBRSxNQUFNLGdCQUFnQixDQUFBO0FBQ2pHLE9BQU8sRUFBRSxPQUFPLElBQUksTUFBTSxFQUFFLGFBQWEsRUFBRSxNQUFNLDJCQUEyQixDQUFBO0FBQzVFLE9BQU8sRUFBRSwwQkFBMEIsRUFBRSxNQUFNLGtDQUFrQyxDQUFBO0FBRTdFO0lBQUE7SUFPQSxDQUFDO0lBQUQscUJBQUM7QUFBRCxDQUFDLEFBUEQsSUFPQzs7QUFFRCxNQUFNLENBQUMsSUFBTSwwQkFBMEIsR0FBYTtJQUNsRCxPQUFPLEVBQUUsaUJBQWlCO0lBQzFCLFdBQVcsRUFBRSxVQUFVLENBQUMsY0FBTSxPQUFBLG9CQUFvQixFQUFwQixDQUFvQixDQUFDO0lBQ25ELEtBQUssRUFBRSxJQUFJO0NBQ1osQ0FBQTtBQUVEOzs7R0FHRztBQUNILFNBQVMsVUFBVTtJQUNqQixJQUFNLFNBQVMsR0FBRyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQTtJQUN6RCxPQUFPLGVBQWUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUE7QUFDdEQsQ0FBQztBQWNEO0lBa0JFLDhCQUNFLGVBQWlDLEVBQ3pCLFdBQXVCLEVBQ3NCLGdCQUF5QjtRQUR0RSxn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RUFBRSxZQUFZO1lBQ3RCLFFBQVEsRUFBRSxVQUFVO1lBQ3BCLFNBQVMsRUFBRSxDQUFDLDBCQUEwQixDQUFDO1NBQ3hDLENBQUM7UUFzQkcsV0FBQSxRQUFRLEVBQUUsQ0FBQSxFQUFFLFdBQUEsTUFBTSxDQUFDLHVCQUF1QixDQUFDLENBQUE7T0FyQm5DLG9CQUFvQixDQStGaEM7SUFBRCwyQkFBQztDQUFBLEFBL0ZELElBK0ZDO1NBL0ZZLG9CQUFvQjtBQXdHakM7SUFBQTtJQUE4QixDQUFDO0lBQWxCLGNBQWM7UUFQMUIsUUFBUSxDQUFDO1lBQ1IsT0FBTyxFQUFFO2dCQUNQLGFBQWE7YUFDZDtZQUNELFlBQVksRUFBRSxDQUFDLG9CQUFvQixDQUFDO1lBQ3BDLE9BQU8sRUFBRSxDQUFDLG9CQUFvQixDQUFDO1NBQ2hDLENBQUM7T0FDVyxjQUFjLENBQUk7SUFBRCxxQkFBQztDQUFBLEFBQS9CLElBQStCO1NBQWxCLGNBQWM7QUFFM0IsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLGtDQUFrQyxDQUFBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBmb3J3YXJkUmVmLCBJbnB1dCwgSW5qZWN0LCBOZ01vZHVsZSxcbiAgT25DaGFuZ2VzLCBPcHRpb25hbCwgUHJvdmlkZXIsIFNpbXBsZUNoYW5nZXMsIEluamVjdGFibGUsIFJlbmRlcmVyRmFjdG9yeTJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSdcbmltcG9ydCB7IE5HX1ZBTFVFX0FDQ0VTU09SLCBDb250cm9sVmFsdWVBY2Nlc3NvciwgQ09NUE9TSVRJT05fQlVGRkVSX01PREUgfSBmcm9tICdAYW5ndWxhci9mb3JtcydcbmltcG9ydCB7IMm1Z2V0RE9NIGFzIGdldERPTSwgQnJvd3Nlck1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInXG5pbXBvcnQgeyBjcmVhdGVUZXh0TWFza0lucHV0RWxlbWVudCB9IGZyb20gJ3RleHQtbWFzay1jb3JlL2Rpc3QvdGV4dE1hc2tDb3JlJ1xuXG5leHBvcnQgY2xhc3MgVGV4dE1hc2tDb25maWcge1xuICBtYXNrOiBBcnJheTxzdHJpbmcgfCBSZWdFeHA+IHwgKChyYXc6IHN0cmluZykgPT4gQXJyYXk8c3RyaW5nIHwgUmVnRXhwPikgfCBmYWxzZVxuICBndWlkZT86IGJvb2xlYW5cbiAgcGxhY2Vob2xkZXJDaGFyPzogc3RyaW5nXG4gIHBpcGU/OiAoY29uZm9ybWVkVmFsdWU6IHN0cmluZywgY29uZmlnOiBUZXh0TWFza0NvbmZpZykgPT4gZmFsc2UgfCBzdHJpbmcgfCBvYmplY3RcbiAga2VlcENoYXJQb3NpdGlvbnM/OiBib29sZWFuXG4gIHNob3dNYXNrPzogYm9vbGVhblxufVxuXG5leHBvcnQgY29uc3QgTUFTS0VESU5QVVRfVkFMVUVfQUNDRVNTT1I6IFByb3ZpZGVyID0ge1xuICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTWFza2VkSW5wdXREaXJlY3RpdmUpLFxuICBtdWx0aTogdHJ1ZVxufVxuXG4vKipcbiAqIFdlIG11c3QgY2hlY2sgd2hldGhlciB0aGUgYWdlbnQgaXMgQW5kcm9pZCBiZWNhdXNlIGNvbXBvc2l0aW9uIGV2ZW50c1xuICogYmVoYXZlIGRpZmZlcmVudGx5IGJldHdlZW4gaU9TIGFuZCBBbmRyb2lkLlxuICovXG5mdW5jdGlvbiBfaXNBbmRyb2lkKCk6IGJvb2xlYW4ge1xuICBjb25zdCB1c2VyQWdlbnQgPSBnZXRET00oKSA/IGdldERPTSgpLmdldFVzZXJBZ2VudCgpIDogJydcbiAgcmV0dXJuIC9hbmRyb2lkIChcXGQrKS8udGVzdCh1c2VyQWdlbnQudG9Mb3dlckNhc2UoKSlcbn1cblxuQEluamVjdGFibGUoKVxuQERpcmVjdGl2ZSh7XG4gIGhvc3Q6IHtcbiAgICAnKGlucHV0KSc6ICdfaGFuZGxlSW5wdXQoJGV2ZW50LnRhcmdldC52YWx1ZSknLFxuICAgICcoYmx1ciknOiAnb25Ub3VjaGVkKCknLFxuICAgICcoY29tcG9zaXRpb25zdGFydCknOiAnX2NvbXBvc2l0aW9uU3RhcnQoKScsXG4gICAgJyhjb21wb3NpdGlvbmVuZCknOiAnX2NvbXBvc2l0aW9uRW5kKCRldmVudC50YXJnZXQudmFsdWUpJ1xuICB9LFxuICBzZWxlY3RvcjogJ1t0ZXh0TWFza10nLFxuICBleHBvcnRBczogJ3RleHRNYXNrJyxcbiAgcHJvdmlkZXJzOiBbTUFTS0VESU5QVVRfVkFMVUVfQUNDRVNTT1JdXG59KVxuZXhwb3J0IGNsYXNzIE1hc2tlZElucHV0RGlyZWN0aXZlIGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3IsIE9uQ2hhbmdlcyB7XG4gIEBJbnB1dCgndGV4dE1hc2snKSB0ZXh0TWFza0NvbmZpZzogVGV4dE1hc2tDb25maWcgPSB7XG4gICAgbWFzazogW10sXG4gICAgZ3VpZGU6IHRydWUsXG4gICAgcGxhY2Vob2xkZXJDaGFyOiAnXycsXG4gICAgcGlwZTogdW5kZWZpbmVkLFxuICAgIGtlZXBDaGFyUG9zaXRpb25zOiBmYWxzZSxcbiAgfVxuXG4gIG9uQ2hhbmdlID0gKF86IGFueSkgPT4geyB9XG4gIG9uVG91Y2hlZCA9ICgpID0+IHsgfVxuXG4gIHByaXZhdGUgdGV4dE1hc2tJbnB1dEVsZW1lbnQ6IGFueVxuICBwcml2YXRlIGlucHV0RWxlbWVudDogSFRNTElucHV0RWxlbWVudFxuICBwcml2YXRlIF9yZW5kZXJlcjogYW55O1xuICAvKiogV2hldGhlciB0aGUgdXNlciBpcyBjcmVhdGluZyBhIGNvbXBvc2l0aW9uIHN0cmluZyAoSU1FIGV2ZW50cykuICovXG4gIHByaXZhdGUgX2NvbXBvc2luZyA9IGZhbHNlXG5cbiAgY29uc3RydWN0b3IoXG4gICAgcmVuZGVyZXJGYWN0b3J5OiBSZW5kZXJlckZhY3RvcnkyLFxuICAgIHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG4gICAgQE9wdGlvbmFsKCkgQEluamVjdChDT01QT1NJVElPTl9CVUZGRVJfTU9ERSkgcHJpdmF0ZSBfY29tcG9zaXRpb25Nb2RlOiBib29sZWFuXG4gICkge1xuICAgIHRoaXMuX3JlbmRlcmVyID0gcmVuZGVyZXJGYWN0b3J5LmNyZWF0ZVJlbmRlcmVyKG51bGwsIG51bGwpO1xuICAgIGlmICh0aGlzLl9jb21wb3NpdGlvbk1vZGUgPT0gbnVsbCkge1xuICAgICAgdGhpcy5fY29tcG9zaXRpb25Nb2RlID0gIV9pc0FuZHJvaWQoKVxuICAgIH1cbiAgfVxuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICB0aGlzLl9zZXR1cE1hc2sodHJ1ZSlcbiAgICBpZiAodGhpcy50ZXh0TWFza0lucHV0RWxlbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnRleHRNYXNrSW5wdXRFbGVtZW50LnVwZGF0ZSh0aGlzLmlucHV0RWxlbWVudC52YWx1ZSlcbiAgICB9XG4gIH1cblxuICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpIHtcbiAgICB0aGlzLl9zZXR1cE1hc2soKVxuXG4gICAgLy8gc2V0IHRoZSBpbml0aWFsIHZhbHVlIGZvciBjYXNlcyB3aGVyZSB0aGUgbWFzayBpcyBkaXNhYmxlZFxuICAgIGNvbnN0IG5vcm1hbGl6ZWRWYWx1ZSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlXG4gICAgdGhpcy5fcmVuZGVyZXIuc2V0UHJvcGVydHkodGhpcy5pbnB1dEVsZW1lbnQsICd2YWx1ZScsIG5vcm1hbGl6ZWRWYWx1ZSlcblxuICAgIGlmICh0aGlzLnRleHRNYXNrSW5wdXRFbGVtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMudGV4dE1hc2tJbnB1dEVsZW1lbnQudXBkYXRlKHZhbHVlKVxuICAgIH1cbiAgfVxuXG4gIHJlZ2lzdGVyT25DaGFuZ2UoZm46IChfOiBhbnkpID0+IHZvaWQpOiB2b2lkIHsgdGhpcy5vbkNoYW5nZSA9IGZuIH1cbiAgcmVnaXN0ZXJPblRvdWNoZWQoZm46ICgpID0+IHZvaWQpOiB2b2lkIHsgdGhpcy5vblRvdWNoZWQgPSBmbiB9XG5cbiAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgdGhpcy5fcmVuZGVyZXIuc2V0UHJvcGVydHkodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnZGlzYWJsZWQnLCBpc0Rpc2FibGVkKVxuICB9XG5cblxuICBfaGFuZGxlSW5wdXQodmFsdWUpIHtcbiAgICBpZiAoIXRoaXMuX2NvbXBvc2l0aW9uTW9kZSB8fCAodGhpcy5fY29tcG9zaXRpb25Nb2RlICYmICF0aGlzLl9jb21wb3NpbmcpKSB7XG4gICAgICB0aGlzLl9zZXR1cE1hc2soKVxuXG4gICAgICBpZiAodGhpcy50ZXh0TWFza0lucHV0RWxlbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMudGV4dE1hc2tJbnB1dEVsZW1lbnQudXBkYXRlKHZhbHVlKVxuXG4gICAgICAgIC8vIGdldCB0aGUgdXBkYXRlZCB2YWx1ZVxuICAgICAgICB2YWx1ZSA9IHRoaXMuaW5wdXRFbGVtZW50LnZhbHVlXG4gICAgICAgIHRoaXMub25DaGFuZ2UodmFsdWUpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX3NldHVwTWFzayhjcmVhdGUgPSBmYWxzZSkge1xuICAgIGlmICghdGhpcy5pbnB1dEVsZW1lbnQpIHtcbiAgICAgIGlmICh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQudGFnTmFtZS50b1VwcGVyQ2FzZSgpID09PSAnSU5QVVQnKSB7XG4gICAgICAgIC8vIGB0ZXh0TWFza2AgZGlyZWN0aXZlIGlzIHVzZWQgZGlyZWN0bHkgb24gYW4gaW5wdXQgZWxlbWVudFxuICAgICAgICB0aGlzLmlucHV0RWxlbWVudCA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYHRleHRNYXNrYCBkaXJlY3RpdmUgaXMgdXNlZCBvbiBhbiBhYnN0cmFjdGVkIGlucHV0IGVsZW1lbnQsIGBtZC1pbnB1dC1jb250YWluZXJgLCBldGNcbiAgICAgICAgdGhpcy5pbnB1dEVsZW1lbnQgPSB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ0lOUFVUJylbMF1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5pbnB1dEVsZW1lbnQgJiYgY3JlYXRlKSB7XG4gICAgICB0aGlzLnRleHRNYXNrSW5wdXRFbGVtZW50ID0gY3JlYXRlVGV4dE1hc2tJbnB1dEVsZW1lbnQoXG4gICAgICAgIE9iamVjdC5hc3NpZ24oeyBpbnB1dEVsZW1lbnQ6IHRoaXMuaW5wdXRFbGVtZW50IH0sIHRoaXMudGV4dE1hc2tDb25maWcpXG4gICAgICApXG4gICAgfVxuXG4gIH1cblxuICBfY29tcG9zaXRpb25TdGFydCgpOiB2b2lkIHsgdGhpcy5fY29tcG9zaW5nID0gdHJ1ZSB9XG5cbiAgX2NvbXBvc2l0aW9uRW5kKHZhbHVlOiBhbnkpOiB2b2lkIHtcbiAgICB0aGlzLl9jb21wb3NpbmcgPSBmYWxzZVxuICAgIHRoaXMuX2NvbXBvc2l0aW9uTW9kZSAmJiB0aGlzLl9oYW5kbGVJbnB1dCh2YWx1ZSlcbiAgfVxufVxuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbXG4gICAgQnJvd3Nlck1vZHVsZVxuICBdLFxuICBkZWNsYXJhdGlvbnM6IFtNYXNrZWRJbnB1dERpcmVjdGl2ZV0sXG4gIGV4cG9ydHM6IFtNYXNrZWRJbnB1dERpcmVjdGl2ZV1cbn0pXG5leHBvcnQgY2xhc3MgVGV4dE1hc2tNb2R1bGUgeyB9XG5cbmV4cG9ydCB7IGNvbmZvcm1Ub01hc2sgfSBmcm9tICd0ZXh0LW1hc2stY29yZS9kaXN0L3RleHRNYXNrQ29yZSciXX0=