import { __decorate, __param } from "tslib";
import { Directive, ElementRef, forwardRef, Input, Inject, NgModule, OnChanges, Optional, Provider, SimpleChanges, Injectable, RendererFactory2 } from '@angular/core';
import { NG_VALUE_ACCESSOR, COMPOSITION_BUFFER_MODE } from '@angular/forms';
import { ÉµgetDOM as getDOM, BrowserModule } from '@angular/platform-browser';
import { createTextMaskInputElement } from 'text-mask-core/dist/textMaskCore';
export class TextMaskConfig {
}
export const MASKEDINPUT_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => MaskedInputDirective),
    multi: true
};
/**
 * We must check whether the agent is Android because composition events
 * behave differently between iOS and Android.
 */
function _isAndroid() {
    const userAgent = getDOM() ? getDOM().getUserAgent() : '';
    return /android (\d+)/.test(userAgent.toLowerCase());
}
let MaskedInputDirective = class MaskedInputDirective {
    constructor(rendererFactory, _elementRef, _compositionMode) {
        this._elementRef = _elementRef;
        this._compositionMode = _compositionMode;
        this.textMaskConfig = {
            mask: [],
            guide: true,
            placeholderChar: '_',
            pipe: undefined,
            keepCharPositions: false,
        };
        this.onChange = (_) => { };
        this.onTouched = () => { };
        /** Whether the user is creating a composition string (IME events). */
        this._composing = false;
        this._renderer = rendererFactory.createRenderer(null, null);
        if (this._compositionMode == null) {
            this._compositionMode = !_isAndroid();
        }
    }
    ngOnChanges(changes) {
        this._setupMask(true);
        if (this.textMaskInputElement !== undefined) {
            this.textMaskInputElement.update(this.inputElement.value);
        }
    }
    writeValue(value) {
        this._setupMask();
        // set the initial value for cases where the mask is disabled
        const normalizedValue = value == null ? '' : value;
        this._renderer.setProperty(this.inputElement, 'value', normalizedValue);
        if (this.textMaskInputElement !== undefined) {
            this.textMaskInputElement.update(value);
        }
    }
    registerOnChange(fn) { this.onChange = fn; }
    registerOnTouched(fn) { this.onTouched = fn; }
    setDisabledState(isDisabled) {
        this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
    }
    _handleInput(value) {
        if (!this._compositionMode || (this._compositionMode && !this._composing)) {
            this._setupMask();
            if (this.textMaskInputElement !== undefined) {
                this.textMaskInputElement.update(value);
                // get the updated value
                value = this.inputElement.value;
                this.onChange(value);
            }
        }
    }
    _setupMask(create = false) {
        if (!this.inputElement) {
            if (this._elementRef.nativeElement.tagName.toUpperCase() === 'INPUT') {
                // `textMask` directive is used directly on an input element
                this.inputElement = this._elementRef.nativeElement;
            }
            else {
                // `textMask` directive is used on an abstracted input element, `md-input-container`, etc
                this.inputElement = this._elementRef.nativeElement.getElementsByTagName('INPUT')[0];
            }
        }
        if (this.inputElement && create) {
            this.textMaskInputElement = createTextMaskInputElement(Object.assign({ inputElement: this.inputElement }, this.textMaskConfig));
        }
    }
    _compositionStart() { this._composing = true; }
    _compositionEnd(value) {
        this._composing = false;
        this._compositionMode && this._handleInput(value);
    }
};
MaskedInputDirective.ctorParameters = () => [
    { type: RendererFactory2 },
    { type: ElementRef },
    { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: [COMPOSITION_BUFFER_MODE,] }] }
];
__decorate([
    Input('textMask')
], MaskedInputDirective.prototype, "textMaskConfig", void 0);
MaskedInputDirective = __decorate([
    Injectable(),
    Directive({
        host: {
            '(input)': '_handleInput($event.target.value)',
            '(blur)': 'onTouched()',
            '(compositionstart)': '_compositionStart()',
            '(compositionend)': '_compositionEnd($event.target.value)'
        },
        selector: '[textMask]',
        exportAs: 'textMask',
        providers: [MASKEDINPUT_VALUE_ACCESSOR]
    }),
    __param(2, Optional()), __param(2, Inject(COMPOSITION_BUFFER_MODE))
], MaskedInputDirective);
export { MaskedInputDirective };
let TextMaskModule = class TextMaskModule {
};
TextMaskModule = __decorate([
    NgModule({
        imports: [
            BrowserModule
        ],
        declarations: [MaskedInputDirective],
        exports: [MaskedInputDirective]
    })
], TextMaskModule);
export { TextMaskModule };
export { conformToMask } from 'text-mask-core/dist/textMaskCore';
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ndWxhcjJUZXh0TWFzay5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25nLWJyYXppbC8iLCJzb3VyY2VzIjpbImFuZ3VsYXIyVGV4dE1hc2sudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFDTCxTQUFTLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFDMUQsU0FBUyxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsYUFBYSxFQUFFLFVBQVUsRUFBRSxnQkFBZ0IsRUFDM0UsTUFBTSxlQUFlLENBQUE7QUFDdEIsT0FBTyxFQUFFLGlCQUFpQixFQUF3Qix1QkFBdUIsRUFBRSxNQUFNLGdCQUFnQixDQUFBO0FBQ2pHLE9BQU8sRUFBRSxPQUFPLElBQUksTUFBTSxFQUFFLGFBQWEsRUFBRSxNQUFNLDJCQUEyQixDQUFBO0FBQzVFLE9BQU8sRUFBRSwwQkFBMEIsRUFBRSxNQUFNLGtDQUFrQyxDQUFBO0FBRTdFLE1BQU0sT0FBTyxjQUFjO0NBTzFCO0FBRUQsTUFBTSxDQUFDLE1BQU0sMEJBQTBCLEdBQWE7SUFDbEQsT0FBTyxFQUFFLGlCQUFpQjtJQUMxQixXQUFXLEVBQUUsVUFBVSxDQUFDLEdBQUcsRUFBRSxDQUFDLG9CQUFvQixDQUFDO0lBQ25ELEtBQUssRUFBRSxJQUFJO0NBQ1osQ0FBQTtBQUVEOzs7R0FHRztBQUNILFNBQVMsVUFBVTtJQUNqQixNQUFNLFNBQVMsR0FBRyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQTtJQUN6RCxPQUFPLGVBQWUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUE7QUFDdEQsQ0FBQztBQWNELElBQWEsb0JBQW9CLEdBQWpDLE1BQWEsb0JBQW9CO0lBa0IvQixZQUNFLGVBQWlDLEVBQ3pCLFdBQXVCLEVBQ3NCLGdCQUF5QjtRQUR0RSxnQkFB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QUMsMEJBQTBCLENBQUM7S0FDeEMsQ0FBQztJQXNCRyxXQUFBLFFBQVEsRUFBRSxDQUFBLEVBQUUsV0FBQSxNQUFNLENBQUMsdUJBQXVCLENBQUMsQ0FBQTtHQXJCbkMsb0JBQW9CLENBK0ZoQztTQS9GWSxvQkFBb0I7QUF3R2pDLElBQWEsY0FBYyxHQUEzQixNQUFhLGNBQWM7Q0FBSSxDQUFBO0FBQWxCLGNBQWM7SUFQMUIsUUFBUSxDQUFDO1FBQ1IsT0FBTyxFQUFFO1lBQ1AsYUFBYTtTQUNkO1FBQ0QsWUFBWSxFQUFFLENBQUMsb0JBQW9CLENBQUM7UUFDcEMsT0FBTyxFQUFFLENBQUMsb0JBQW9CLENBQUM7S0FDaEMsQ0FBQztHQUNXLGNBQWMsQ0FBSTtTQUFsQixjQUFjO0FBRTNCLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxrQ0FBa0MsQ0FBQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgZm9yd2FyZFJlZiwgSW5wdXQsIEluamVjdCwgTmdNb2R1bGUsXG4gIE9uQ2hhbmdlcywgT3B0aW9uYWwsIFByb3ZpZGVyLCBTaW1wbGVDaGFuZ2VzLCBJbmplY3RhYmxlLCBSZW5kZXJlckZhY3RvcnkyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnXG5pbXBvcnQgeyBOR19WQUxVRV9BQ0NFU1NPUiwgQ29udHJvbFZhbHVlQWNjZXNzb3IsIENPTVBPU0lUSU9OX0JVRkZFUl9NT0RFIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnXG5pbXBvcnQgeyDJtWdldERPTSBhcyBnZXRET00sIEJyb3dzZXJNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJ1xuaW1wb3J0IHsgY3JlYXRlVGV4dE1hc2tJbnB1dEVsZW1lbnQgfSBmcm9tICd0ZXh0LW1hc2stY29yZS9kaXN0L3RleHRNYXNrQ29yZSdcblxuZXhwb3J0IGNsYXNzIFRleHRNYXNrQ29uZmlnIHtcbiAgbWFzazogQXJyYXk8c3RyaW5nIHwgUmVnRXhwPiB8ICgocmF3OiBzdHJpbmcpID0+IEFycmF5PHN0cmluZyB8IFJlZ0V4cD4pIHwgZmFsc2VcbiAgZ3VpZGU/OiBib29sZWFuXG4gIHBsYWNlaG9sZGVyQ2hhcj86IHN0cmluZ1xuICBwaXBlPzogKGNvbmZvcm1lZFZhbHVlOiBzdHJpbmcsIGNvbmZpZzogVGV4dE1hc2tDb25maWcpID0+IGZhbHNlIHwgc3RyaW5nIHwgb2JqZWN0XG4gIGtlZXBDaGFyUG9zaXRpb25zPzogYm9vbGVhblxuICBzaG93TWFzaz86IGJvb2xlYW5cbn1cblxuZXhwb3J0IGNvbnN0IE1BU0tFRElOUFVUX1ZBTFVFX0FDQ0VTU09SOiBQcm92aWRlciA9IHtcbiAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE1hc2tlZElucHV0RGlyZWN0aXZlKSxcbiAgbXVsdGk6IHRydWVcbn1cblxuLyoqXG4gKiBXZSBtdXN0IGNoZWNrIHdoZXRoZXIgdGhlIGFnZW50IGlzIEFuZHJvaWQgYmVjYXVzZSBjb21wb3NpdGlvbiBldmVudHNcbiAqIGJlaGF2ZSBkaWZmZXJlbnRseSBiZXR3ZWVuIGlPUyBhbmQgQW5kcm9pZC5cbiAqL1xuZnVuY3Rpb24gX2lzQW5kcm9pZCgpOiBib29sZWFuIHtcbiAgY29uc3QgdXNlckFnZW50ID0gZ2V0RE9NKCkgPyBnZXRET00oKS5nZXRVc2VyQWdlbnQoKSA6ICcnXG4gIHJldHVybiAvYW5kcm9pZCAoXFxkKykvLnRlc3QodXNlckFnZW50LnRvTG93ZXJDYXNlKCkpXG59XG5cbkBJbmplY3RhYmxlKClcbkBEaXJlY3RpdmUoe1xuICBob3N0OiB7XG4gICAgJyhpbnB1dCknOiAnX2hhbmRsZUlucHV0KCRldmVudC50YXJnZXQudmFsdWUpJyxcbiAgICAnKGJsdXIpJzogJ29uVG91Y2hlZCgpJyxcbiAgICAnKGNvbXBvc2l0aW9uc3RhcnQpJzogJ19jb21wb3NpdGlvblN0YXJ0KCknLFxuICAgICcoY29tcG9zaXRpb25lbmQpJzogJ19jb21wb3NpdGlvbkVuZCgkZXZlbnQudGFyZ2V0LnZhbHVlKSdcbiAgfSxcbiAgc2VsZWN0b3I6ICdbdGV4dE1hc2tdJyxcbiAgZXhwb3J0QXM6ICd0ZXh0TWFzaycsXG4gIHByb3ZpZGVyczogW01BU0tFRElOUFVUX1ZBTFVFX0FDQ0VTU09SXVxufSlcbmV4cG9ydCBjbGFzcyBNYXNrZWRJbnB1dERpcmVjdGl2ZSBpbXBsZW1lbnRzIENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBPbkNoYW5nZXMge1xuICBASW5wdXQoJ3RleHRNYXNrJykgdGV4dE1hc2tDb25maWc6IFRleHRNYXNrQ29uZmlnID0ge1xuICAgIG1hc2s6IFtdLFxuICAgIGd1aWRlOiB0cnVlLFxuICAgIHBsYWNlaG9sZGVyQ2hhcjogJ18nLFxuICAgIHBpcGU6IHVuZGVmaW5lZCxcbiAgICBrZWVwQ2hhclBvc2l0aW9uczogZmFsc2UsXG4gIH1cblxuICBvbkNoYW5nZSA9IChfOiBhbnkpID0+IHsgfVxuICBvblRvdWNoZWQgPSAoKSA9PiB7IH1cblxuICBwcml2YXRlIHRleHRNYXNrSW5wdXRFbGVtZW50OiBhbnlcbiAgcHJpdmF0ZSBpbnB1dEVsZW1lbnQ6IEhUTUxJbnB1dEVsZW1lbnRcbiAgcHJpdmF0ZSBfcmVuZGVyZXI6IGFueTtcbiAgLyoqIFdoZXRoZXIgdGhlIHVzZXIgaXMgY3JlYXRpbmcgYSBjb21wb3NpdGlvbiBzdHJpbmcgKElNRSBldmVudHMpLiAqL1xuICBwcml2YXRlIF9jb21wb3NpbmcgPSBmYWxzZVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHJlbmRlcmVyRmFjdG9yeTogUmVuZGVyZXJGYWN0b3J5MixcbiAgICBwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgIEBPcHRpb25hbCgpIEBJbmplY3QoQ09NUE9TSVRJT05fQlVGRkVSX01PREUpIHByaXZhdGUgX2NvbXBvc2l0aW9uTW9kZTogYm9vbGVhblxuICApIHtcbiAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyRmFjdG9yeS5jcmVhdGVSZW5kZXJlcihudWxsLCBudWxsKTtcbiAgICBpZiAodGhpcy5fY29tcG9zaXRpb25Nb2RlID09IG51bGwpIHtcbiAgICAgIHRoaXMuX2NvbXBvc2l0aW9uTW9kZSA9ICFfaXNBbmRyb2lkKClcbiAgICB9XG4gIH1cblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG4gICAgdGhpcy5fc2V0dXBNYXNrKHRydWUpXG4gICAgaWYgKHRoaXMudGV4dE1hc2tJbnB1dEVsZW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy50ZXh0TWFza0lucHV0RWxlbWVudC51cGRhdGUodGhpcy5pbnB1dEVsZW1lbnQudmFsdWUpXG4gICAgfVxuICB9XG5cbiAgd3JpdGVWYWx1ZSh2YWx1ZTogYW55KSB7XG4gICAgdGhpcy5fc2V0dXBNYXNrKClcblxuICAgIC8vIHNldCB0aGUgaW5pdGlhbCB2YWx1ZSBmb3IgY2FzZXMgd2hlcmUgdGhlIG1hc2sgaXMgZGlzYWJsZWRcbiAgICBjb25zdCBub3JtYWxpemVkVmFsdWUgPSB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZVxuICAgIHRoaXMuX3JlbmRlcmVyLnNldFByb3BlcnR5KHRoaXMuaW5wdXRFbGVtZW50LCAndmFsdWUnLCBub3JtYWxpemVkVmFsdWUpXG5cbiAgICBpZiAodGhpcy50ZXh0TWFza0lucHV0RWxlbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnRleHRNYXNrSW5wdXRFbGVtZW50LnVwZGF0ZSh2YWx1ZSlcbiAgICB9XG4gIH1cblxuICByZWdpc3Rlck9uQ2hhbmdlKGZuOiAoXzogYW55KSA9PiB2b2lkKTogdm9pZCB7IHRoaXMub25DaGFuZ2UgPSBmbiB9XG4gIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiAoKSA9PiB2b2lkKTogdm9pZCB7IHRoaXMub25Ub3VjaGVkID0gZm4gfVxuXG4gIHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZDogYm9vbGVhbik6IHZvaWQge1xuICAgIHRoaXMuX3JlbmRlcmVyLnNldFByb3BlcnR5KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2Rpc2FibGVkJywgaXNEaXNhYmxlZClcbiAgfVxuXG5cbiAgX2hhbmRsZUlucHV0KHZhbHVlKSB7XG4gICAgaWYgKCF0aGlzLl9jb21wb3NpdGlvbk1vZGUgfHwgKHRoaXMuX2NvbXBvc2l0aW9uTW9kZSAmJiAhdGhpcy5fY29tcG9zaW5nKSkge1xuICAgICAgdGhpcy5fc2V0dXBNYXNrKClcblxuICAgICAgaWYgKHRoaXMudGV4dE1hc2tJbnB1dEVsZW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnRleHRNYXNrSW5wdXRFbGVtZW50LnVwZGF0ZSh2YWx1ZSlcblxuICAgICAgICAvLyBnZXQgdGhlIHVwZGF0ZWQgdmFsdWVcbiAgICAgICAgdmFsdWUgPSB0aGlzLmlucHV0RWxlbWVudC52YWx1ZVxuICAgICAgICB0aGlzLm9uQ2hhbmdlKHZhbHVlKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9zZXR1cE1hc2soY3JlYXRlID0gZmFsc2UpIHtcbiAgICBpZiAoIXRoaXMuaW5wdXRFbGVtZW50KSB7XG4gICAgICBpZiAodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnRhZ05hbWUudG9VcHBlckNhc2UoKSA9PT0gJ0lOUFVUJykge1xuICAgICAgICAvLyBgdGV4dE1hc2tgIGRpcmVjdGl2ZSBpcyB1c2VkIGRpcmVjdGx5IG9uIGFuIGlucHV0IGVsZW1lbnRcbiAgICAgICAgdGhpcy5pbnB1dEVsZW1lbnQgPSB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGB0ZXh0TWFza2AgZGlyZWN0aXZlIGlzIHVzZWQgb24gYW4gYWJzdHJhY3RlZCBpbnB1dCBlbGVtZW50LCBgbWQtaW5wdXQtY29udGFpbmVyYCwgZXRjXG4gICAgICAgIHRoaXMuaW5wdXRFbGVtZW50ID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdJTlBVVCcpWzBdXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaW5wdXRFbGVtZW50ICYmIGNyZWF0ZSkge1xuICAgICAgdGhpcy50ZXh0TWFza0lucHV0RWxlbWVudCA9IGNyZWF0ZVRleHRNYXNrSW5wdXRFbGVtZW50KFxuICAgICAgICBPYmplY3QuYXNzaWduKHsgaW5wdXRFbGVtZW50OiB0aGlzLmlucHV0RWxlbWVudCB9LCB0aGlzLnRleHRNYXNrQ29uZmlnKVxuICAgICAgKVxuICAgIH1cblxuICB9XG5cbiAgX2NvbXBvc2l0aW9uU3RhcnQoKTogdm9pZCB7IHRoaXMuX2NvbXBvc2luZyA9IHRydWUgfVxuXG4gIF9jb21wb3NpdGlvbkVuZCh2YWx1ZTogYW55KTogdm9pZCB7XG4gICAgdGhpcy5fY29tcG9zaW5nID0gZmFsc2VcbiAgICB0aGlzLl9jb21wb3NpdGlvbk1vZGUgJiYgdGhpcy5faGFuZGxlSW5wdXQodmFsdWUpXG4gIH1cbn1cblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW1xuICAgIEJyb3dzZXJNb2R1bGVcbiAgXSxcbiAgZGVjbGFyYXRpb25zOiBbTWFza2VkSW5wdXREaXJlY3RpdmVdLFxuICBleHBvcnRzOiBbTWFza2VkSW5wdXREaXJlY3RpdmVdXG59KVxuZXhwb3J0IGNsYXNzIFRleHRNYXNrTW9kdWxlIHsgfVxuXG5leHBvcnQgeyBjb25mb3JtVG9NYXNrIH0gZnJvbSAndGV4dC1tYXNrLWNvcmUvZGlzdC90ZXh0TWFza0NvcmUnIl19